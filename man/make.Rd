% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make.R
\name{make}
\alias{make}
\alias{\%<=\%}
\alias{\%=>\%}
\alias{\%<<=\%}
\alias{\%=>>\%}
\alias{do_make}
\alias{do.make}
\alias{make_all}
\alias{make_tests}
\alias{make_all_tests}
\title{Make a Module.}
\usage{
make(name = .Last.name, ...)

do_make(
  name = .Last.name,
  args = list(),
  quote = FALSE,
  envir = parent.frame(1L)
)

do.make(
  name = .Last.name,
  args = list(),
  quote = FALSE,
  envir = parent.frame(1L)
)

make_all(regexp, reserved = FALSE, error = stop)

make_tests(
  pattern = NULL,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE,
  invert = FALSE
)

make_all_tests(...)
}
\arguments{
\item{name}{A string (character vector of lenght one).

  A module name can contain letters, figures and some special characters,
  namely \code{_}, \code{-}, and \code{/}. The latter is a namespace
  separator.

  Names containing \code{/mock/}, \code{/mocks/}, \code{/test/},
  \code{/tests/}, \code{/example/}, or \code{/examples/} have a special
  meaning related to code testing and examples.

  The name "modulr" corresponds to a special module and is therefore
  reserved.}

\item{...}{For \code{make}, further arguments to be passed for evaluation to
the resulting function, if any. For \code{make_all_tests}, further
arguments to be passed to \code{\link{load_all_modules}}.}

\item{args}{A list of arguments to be passed to the resulting function, if
any. The \code{names} attribute of \code{args} gives the argument names.}

\item{quote}{A flag. Should the arguments be quoted?}

\item{envir}{An environment within which to evaluate the function call, if
any. This will be most useful if the arguments are symbols or quoted
expressions.}

\item{regexp}{A regular expression. If not missing, the regular expression
is used to filter the names of the modules to be made.}

\item{reserved}{A flag. Should special modules with a reserved name be
considered?}

\item{error}{A function. This function is triggered on error.}

\item{pattern}{character string containing a \link[base]{regular expression}
    (or character string for \code{fixed = TRUE}) to be matched
    in the given character vector.  Coerced by
    \code{\link[base]{as.character}} to a character string if possible.  If a
    character vector of length 2 or more is supplied, the first element
    is used with a warning.  Missing values are allowed except for
    \code{regexpr} and \code{gregexpr}.}

\item{ignore.case}{if \code{FALSE}, the pattern matching is \emph{case
      sensitive} and if \code{TRUE}, case is ignored during matching.}

\item{perl}{logical.  Should Perl-compatible regexps be used?}

\item{fixed}{logical.  If \code{TRUE}, \code{pattern} is a string to be
    matched as is.  Overrides all conflicting arguments.}

\item{useBytes}{logical.  If \code{TRUE} the matching is done
    byte-by-byte rather than character-by-character.  See
    \sQuote{Details}.}

\item{invert}{logical.  If \code{TRUE} return indices or values for
    elements that do \emph{not} match.}
}
\value{
The object resulting of the evaluation of the provider function of
  the module. If the object is a function and arguments are passed, returns
  the object resulting of the evaluation of the function on these arguments.
}
\description{
Make or remake a module.
}
\details{
A call to the \code{make} function triggers a series of actions, which are
actually the core purposes of the modulr package.
\enumerate{
\item All dependencies are visited and defined, recursively. This process is
based on the explicit and implicit rules of name resolution, as explained in
\code{\link{define}}. In particular, the configurations set by
\code{\link{root_config}}, \code{\link{paths_config}}, and
\code{\link{maps_config}} are taken into account and every module for which
changes are detected is automatically redefined.
\item Along the lines of this recursive process, an internal representation
of the dependencies and the relations between them is constructed. This
provides a directed graph, which vertices represent the modules to be
evaluated, and edges represent constraints on evaluations that must be
performed before others.
\item If no cycle among dependencies is detected, the graph is then a
Directed Acyclic Graph (DAG), and a so called topological sorting can be
performed on it to compute a well ordered sequence of evaluations.
\item Each module provider is then evaluated in the order, or re-evaluated if
outdated, with all its dependencies passed as arguments. A module is
considered outdated when it has been explicitly \code{\link{touch}}ed or if
one of its dependencies has been redefined or is itself outdated. The result
of the evaluation of every module provider is stored in the modulr internal
state, so that it can be reused when appropriate, without re-evaluation.
}

The \code{make_all} function applies \code{make} to each defined module. If a
\code{regexp} is specified, this applies only to modules which name satisfies
the regular expression. Similarily, the \code{make_tests} function applies to
each module which name contains \code{/test/} or \code{/tests/}. It is also
possible to run tests on all modules defined in a named directory with
\code{make_all_tests}.
}
\section{Syntactic Sugars}{

 \preformatted{variable \%<=\% name}
 \preformatted{name \%=>\% variable}
 \preformatted{variable \%<<=\% name}
 \preformatted{name \%=>>\% variable}

The expressions \code{variable \%<=\% name} and \code{name \%=>\% variable}
(respectively \code{variable \%<<=\% name} and \code{name \%=>>\% variable})
are just \emph{syntactic sugars} for the expression
\code{variable <- make(name)} (respectively \code{variable <<- make(name)}).
}

\section{Warning}{

 It is considered a very bad practice to define, touch, undefine, load, make,
 reset, or perform any other operation from within a module definition that
 may alterate the internal state of modulr.
}

\examples{
reset()
define("foo", NULL, function() {
  message("Generating timestamp ...")
  format(Sys.time(), "\%H:\%M:\%OS6")
})
make("foo") # timestamp evaluated at *make-time*, ...
make("foo") # only once

reset()
define("foo", NULL, function() function() {
  message("Generating timestamp ...")
  format(Sys.time(), "\%H:\%M:\%OS6")
})
foo <- make("foo")
foo() # timestamp evaluated at *run-time*, ...
foo() # again, ...
foo() # and again

reset()
define("foo", NULL, function() {
  library(memoise)
  memoise(function() {
    message("Generating timestamp ...")
    format(Sys.time(), "\%H:\%M:\%OS6")
  })
})
foo <- make("foo")
foo() # timestamp evaluated at *run-time*, but ...
foo() # only once

reset()
define("foo", NULL, function() function(a) a + 1L)
foo <- make("foo"); foo(1L)
make("foo", 1L)
do_make("foo", args = list(a = 1L))

reset()
define("A", NULL, function() "(A)")
define("B", NULL, function() "(B)")
define("C", list(a = "A"), function(a) paste0("(", a, "C)"))
define("D", list(a = "A", b = "B"), function(a, b) paste0("(", a, b, "D)"))
define("E", list(d = "D"), function(d) paste0("(", d, "E)"))
define("F", list(c = "C", d = "D", e = "E"),
  function(c, d, e) paste0("(", c, d, e, "F)"))
make()
define("B", NULL, function() "(B')")
make("F")
plot_dependencies()

reset()
tmp_dir <- tempfile("modulr_")
dir.create(tmp_dir)
tmp_file <- file.path(tmp_dir, "foo.R")
cat('define("foo", NULL, function() "Hello World!")', file = tmp_file)
root_config$set(tmp_dir)
set_verbosity(1L)
make("foo")
make("foo")
touch("foo")
make("foo")
unlink(tmp_dir, recursive = TRUE)

\dontrun{
reset()
# https://gist.github.com/aclemen1/3fcc508cb40ddac6c1e3
"modulr/vault" \%imports\%
  paste0("https://gist.githubusercontent.com/aclemen1/",
    "3fcc508cb40ddac6c1e3/raw/modulr-vault.Rmd")
list_modules()
make_tests()
make("modulr/vault/example")
touch("modulr/vault")
make_all()}

}
\seealso{
\code{\link{.Last.name}}, \code{\link{plot_dependencies}},
  \code{\link{import_module}}, \code{\link{maps_config}},
  \code{\link{paths_config}}, \code{\link{reset}}, and \code{\link{touch}}.
}
