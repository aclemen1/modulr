% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/make.R
\name{make}
\alias{\%<<=\%}
\alias{\%<=\%}
\alias{\%=>>\%}
\alias{\%=>\%}
\alias{make}
\alias{make_all}
\alias{make_all_tests}
\alias{make_tests}
\title{Make a Module.}
\usage{
make(name = .Last.name)

make_all(regexp, reserved = FALSE, error = stop)

make_tests()

make_all_tests(...)
}
\arguments{
\item{name}{A string (character vector of lenght one).

  A module name can contain letters, figures and some special characters,
  namely \code{_}, \code{-}, and \code{/}. The latter is a namespace
  separator.

  Names containing \code{/mock/}, \code{/mocks/}, \code{/test/},
  \code{/tests/}, \code{/example/}, or \code{/examples/} have a special
  meaning related to code testing and examples.

  The name "modulr" corresponds to a special module and is therefore
  reserved.}

\item{regexp}{A regular expression. If not missing, the regular expression
is used to filter the names of the modules to be made.}

\item{reserved}{A flag. Should special modules with a reserved name be
considered?}

\item{error}{A function. This function is triggered on error.}

\item{...}{Further arguments to be passed to \code{\link{load_all_modules}}.}
}
\value{
The object resulting of the evaluation of the factory function of the
  module.
}
\description{
Make or remake a module.
}
\details{
A call to the \code{make} function triggers a series of actions, which are
actually the core purposes of the modulr package.
\enumerate{
\item All dependencies are visited and defined, recursively. This process is
based on the explicit and implicit rules of name resolution, as explained in
\code{\link{define}}. In particular, the configurations set by
\code{\link{root_config}}, \code{\link{paths_config}}, and
\code{\link{maps_config}} are taken into account and every module for which
changes are detected is automatically redefined.
\item Along the lines of this recursive process, an internal representation
of the dependencies and the relations between them is constructed. This
provides a directed graph, which vertices represent the modules to be
evaluated, and edges represent constraints on evaluations that must be
performed before others.
\item If no cycle among dependencies is detected, the graph is then a
Directed Acyclic Graph (DAG), and a so called topological sorting can be
performed on it to compute a well ordered sequence of evaluations.
\item Each module factory is then evaluated in the order, or re-evaluated if
outdated, with all its dependencies passed as arguments. A module is
considered outdated when it has been explicitly \code{\link{touch}}ed or if
one of its dependencies has been redefined or is itself outdated. The result
of the evaluation of every module factory is stored in the modulr internal
state, so that it can be reused when appropriate, without re-evaluation.
}

The \code{make_all} function applies \code{make} to each defined module. If a
\code{regexp} is specified, this applies only to modules which name satisfies
the regular expression. Similarily, the \code{make_tests} function applies to
each module which name contains \code{/test/} or \code{/tests/}. It is also
possible to run tests on all modules defined in a named directory with
\code{make_all_tests}.
}
\section{Syntactic Sugars}{

 \preformatted{variable \%<=\% name}
 \preformatted{name \%=>\% variable}
 \preformatted{variable \%<<=\% name}
 \preformatted{name \%=>>\% variable}

The expressions \code{variable \%<=\% name} and \code{name \%=>\% variable}
(respectively \code{variable \%<<=\% name} and \code{name \%=>>\% variable})
are just \emph{syntactic sugars} for the expression
\code{variable <- make(name)} (respectively \code{variable <<- make(name)}).
}

\section{Warning}{

 It is considered a very bad practice to define, touch, undefine, load, make,
 reset, or perform any other operation from within a module definition that
 may alterate the internal state of modulr.
}
\examples{
reset()
define("foo", NULL, function() format(Sys.time(), "\%H:\%M:\%OS6"))
foo <- make("foo")
foo
foo

reset()
define("foo", NULL, function() function() format(Sys.time(), "\%H:\%M:\%OS6"))
foo \%<=\% "foo"
foo()
foo()

reset()
define("A", NULL, function() "(A)")
define("B", NULL, function() "(B)")
define("C", list(a = "A"), function(a) paste0("(", a, "C)"))
define("D", list(a = "A", b = "B"), function(a, b) paste0("(", a, b, "D)"))
define("E", list(d = "D"), function(d) paste0("(", d, "E)"))
define("F", list(c = "C", d = "D", e = "E"),
  function(c, d, e) paste0("(", c, d, e, "F)"))
make()
define("B", NULL, function() "(B')")
make("F")
graph_dependencies()

reset()
tmp_dir <- tempfile("modulr_")
dir.create(tmp_dir)
tmp_file <- file.path(tmp_dir, "foo.R")
cat('define("foo", NULL, function() "Hello World!")', file = tmp_file)
root_config$set(tmp_dir)
set_verbosity(1L)
make("foo")
make("foo")
touch("foo")
make("foo")
unlink(tmp_dir, recursive = TRUE)

\dontrun{
reset()
# https://gist.github.com/aclemen1/3fcc508cb40ddac6c1e3
"modulr/vault" \%imports\%
  paste0("https://gist.githubusercontent.com/aclemen1/",
    "3fcc508cb40ddac6c1e3/raw/modulr-vault.Rmd")
list_modules()
make_tests()
make("modulr/vault/example")
touch("modulr/vault")
make_all()}
}
\seealso{
\code{\link{.Last.name}}, \code{\link{graph_dependencies}},
  \code{\link{import_module}}, \code{\link{make}},
  \code{\link{maps_config}}, \code{\link{paths_config}}, \code{\link{reset}},
  and \code{\link{touch}}.
}

