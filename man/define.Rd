% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/define.R
\name{define}
\alias{define}
\title{Define a Module.}
\usage{
define(name, dependencies, factory)
}
\arguments{
\item{name}{A string (character vector of lenght one).

  A module name can contain letters, figures and some special characters,
  namely \code{_}, \code{-}, and \code{/}. The latter is a namespace
  separator.

  The name "modulr" corresponds to a special module and is therefore
  reserved.}

\item{dependencies}{A (preferably named) list of strings or NULL.

  Elements of the list of dependencies designate modules by their name.}

\item{factory}{A function.

  The formals of the factory must coincide with the list of dependencies.}
}
\value{
A wrapper function around a make call for the defined module.
}
\description{
Define or redefine a module by name, dependencies, and factory.
}
\details{
The definition of a module can be done on-the-fly (in the console or
evaluating a script), from a file which is persistent on a disk or at a given
remote URL via the http(s) protocol. These three ways of defining modules
have their specificities.

\describe{
\item{On-The-Fly Method}{
This is the most direct method to define or redefine a module. This is also
the most volatile since the lifespan of the module is limited to the R
session only. When a new module is defined, the internal state of the package
is modified to record its name, dependencies and factory. Some other useful
metadata are also recorded, like timestamps, various flags and counters, and
a digest. When an existing module is redefined, the internal state is updated
accordingly, unless no change is detected by digests comparison. No other
side-effect occurs during the definition process and notably, the actual
evaluation of the factory takes place uniquely during a \code{\link{make}}
call.
}

\item{Persistent Method}{ This is the natural
method to choose when a module is intended to be reused. In such a case, the
definition takes place in a dedicated file, which name is closely related to
the module's name.

As a file \code{/home/user/readme.txt} is composed of a path
\code{/home/user} and a file name \code{readme.txt}, a module name
\code{vendor/tool/swissknife} is similarily composed of a namespace
\code{vendor/tool} and a local name \code{swissknife}. For modulr to find
this module, it is sufficient to store its definition in an R or R Markdown
file named \code{swissknife.R[md]} (R files have precedence over Rmd's),
laid out on disk in the \code{vendor/tool} path, relative to the modulr
root directory (see \code{\link{root_config}}).

\itemize{
\item \code{vendor/}
\itemize{
\item \code{tool/}
\itemize{
\item \code{swissknife.R},

contains the "vendor/tool/swissknife" definition.}}}

Each time the definition of a module is needed, modulr resolves its name into
a file location by applying the following configurable rules.

\enumerate{
\item
The \code{\link{root_config}} accessor acts at the \emph{filesystem level} by
specifying the root directory, relative to which all paths are expressed. For
instance, \code{root_config$set("./lib")} tells modulr that all modules are
to be found in \code{lib}, in the R working directory. The directory path can
be relative (e.g. \code{./lib}) or absolute (e.g. \code{/home/user/lib}).
By default, modulr looks in turn into the following directories
\code{"./module"}, \code{"./modules"}, \code{"./lib"}, \code{"./libs"},
and \code{"."}.

\item The \code{\link{paths_config}} accessor acts at a \emph{namespace
level} by mapping a specific namespace to a dedicated path, relative to the
root directory. For instance, \code{paths_config$set("vendor" =
"third_parties/vendor")} will map the \code{vendor/great_module} to
the \code{third_parties/vendor/great_module.R[md]} path, relative to the
root directory.
\itemize{
\item \code{third_parties}

is a dedicated container for third-parties modules.
\itemize{
\item \code{vendor}
\itemize{
\item \code{great_module.R}

contains the "vendor/great_module" definition.
}
}
}
\item The \code{\link{maps_config}} accessor acts at a
\emph{module level} by substituting specific dependencies within the scope of
a given module only. This is especially useful in a situation where a
dependency has been replaced by a newer version, but a module still needs to
rely on the older one. For instance, \code{maps_config$set("foo/bar" =
list("vendor/great_module" = "vendor/old_great_module"))} tells
modulr that for the module \code{foo/bar} only, the dependency
\code{vendor/great_module} must be replaced by
\code{vendor/old_great_module}. }

\itemize{
\item \code{foo}
\itemize{
\item \code{bar.R}

depends on \code{vendor/great_module} by definition, but will be replaced by
\code{vendor/old_great_module} when needed.
}
\item \code{vendor}
\itemize{
\item \code{great_module.R}

serves all modules that depend on it, except \code{foo/bar}.
\item \code{old_great_module}

serves \code{foo/bar} only.
}
}

These rules are applied in reverse order, substituting dependencies first,
then mapping namespaces and finally expressing the absolute path, relative to
the modulr root directory.

} \item{Remote Method}{Third item} }
}

