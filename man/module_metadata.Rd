% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modulr.R
\name{module_metadata}
\alias{module_metadata}
\alias{.__name__}
\alias{.__file__}
\alias{.__version__}
\alias{.__namespace__}
\alias{.__initials__}
\alias{.__final__}
\alias{.__path__}
\title{Module Metadata.}
\usage{
.__name__

.__version__

.__namespace__

.__initials__

.__final__

.__file__

.__path__
}
\value{
The name of the current module scope.
}
\description{
Access module metadata.
}
\details{
When modulr loads a module file, it assigns the module's name to
  \code{.__name__}. A module file can discover whether or not it is running
  in the main scope by checking if \code{.__name__} has value
  \code{"__main__"}. This allows a common idiom for conditionally executing
  code in a module file when it is run as a script (see example). It is
  mainly useful when one wants to write a module file which can be executed
  directly as a script and alternatively declared as a dependency and used by
  other modules.
}
\section{Warning}{
 Do not assign to any metadata in the workspace, because
  this will always mask the object of the same name in \code{package:modulr}.
}

\examples{
# script.R
"script" \%provides\% { cat("Hello World\n"); print(.__name__) }
if (.__name__ == "main") make()
# EOF
\dontrun{source("script.R")}
make("script")
}
\seealso{
\code{\link{define}} and \code{\link{make}}.
}
