---
title: "Modulr Guide"
date: "`r Sys.Date()`"
output:
  knitr:::html_vignette:
    toc: true
    fig_caption: yes
  pdf_document:
    highlight: null
    number_sections: yes
vignette: >
  %\VignetteIndexEntry{Modulr Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE, results = 'hide'}
library(modulr)
library(htmltools)
library(networkD3)
require(webshot) # not on CRAN
library(future)
library(memoise)
library(dplyr)
`%<=%` <- modulr::`%<=%`
Sys.setlocale("LC_TIME", "en_DK.UTF-8")
Sys.setenv(TZ = 'UTC')
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "guide-"
)
```

# Introduction

Modulr is a [Dependency Injection](https://en.wikipedia.org/wiki/Dependency_injection) (DI) framework for R. It allows to break down sequential programs into discrete, modular units that are loosely coupled, simple to develop, test, reuse and share. See the [README file](https://github.com/aclemen1/modulr) for a short introduction.

## Anatomy of a module

Modules are defined declaratively using `%requires%` and `%provides%` and have four main components:

* A __name__, which uniquely identifies the module.
* A list of required __dependencies__, if any.
* A __provider__, which expresses the module's feature(s).
* Optional __docstrings__, intended to document the internals of a module.

A typical module looks like the following:

```r
"name_of_module" %requires% list(

  # a list of dependencies
  dependency_1 = "name_of_dependency_1",
  dependency_2 = "name_of_dependency_1"

) %provides% {

  #' a docstring intended to document the internals of the module
  
  # some code that uses the objects `dependency_1` and `dependency_2"
  # returned by the modules "name_of_dependency_1" and "name_of_dependency_2"
  object <- { ... }
  
  # a resulting object, exposed by the module
  return(object)

}
```

When a module is defined, modulr has to _make_ it in order to evaluate the code it provides:

```r
result <- make("name_of_module")
```

or alternatively with a handy syntactic sugar:

```r
result %<=% "name_of_module"
```

The result contains the object computed and exposed by the module. Under the hood, the dependencies have been sorted and also made, and their resulting objects injected where required.

## A first, minimal example

```{r, echo=FALSE, results='hide', message=FALSE}
reset()
```

Let us start by defining some modules and dependencies:

```{r}
"foo" %provides% "Hello"

"bar" %provides% "World"

"foobar" %requires% list(
  f = "foo",
  b = "bar"
) %provides% {
  #' Return a concatenated string.
  paste0(f, " ", b, "!")
}
```

Use `info` to output the docstrings:

```{r}
info("foobar")
```

Use `lsmod` to list all modules and their properties:

```{r}
lsmod(cols = c("name", "type", "dependencies", "uses", "size", "modified"))
```

In this example, `foobar` has two dependencies, and `foo` and `bar` both have one child. Use `plot_dependencies` to see them graphically:

```{r, echo=F}
# Do not try to produce a snapshot on Travis CI or CRAN
if (!identical(Sys.getenv("TRAVIS"), "true") &&
      identical(Sys.getenv("NOT_CRAN"), "true")) {
  plot_dependencies() %>%
    html_print %>%
    webshot(file = "guide-foobar.png", selector = ".sankeyNetwork", delay = 2) %>%
    resize("730x") %>%
    shrink()
}
```

```{r, echo=T, eval=F}
plot_dependencies()
```

![](guide-foobar.png)

Use `make` get the resulting object provided by the module:

```{r}
make("foobar")
```

Voilà! All the depencencies have been evaluated, injected and processed to return the expected `"Hello World!"`.

```{r}
lsmod(cols = c("name", "type", "dependencies", "uses", "size", "modified"))
```

## Workflow

TODO: 

- précédence disque -> registre, également pour %imports%
- injectors
- stashing

# Types of modules

TODO:

- compiler::cmpfun pour compiler les factories


## Modules are singletons

```{r, echo=FALSE, results='hide', message=FALSE}
reset()
```

All modules are singletons in the sense that once evaluated, they always return the same cached object. This is one of the great advantages of modulr: module evaluation takes place parsimoniously, only when changes are detected or explicitely required.

```{r}
"timestamp" %provides% {
  #' Return a string containing a timestamp.
  format(Sys.time(), "%H:%M:%OS6")
}
```

Successive make calls on the module will not imply its re-evaluation:

```{r}
make("timestamp")
with_verbosity(0, make("timestamp")) # temporarily change the verbosity of make
```

To force the re-evaluation of a module, you can use `touch`:

```{r}
touch("timestamp")
make("timestamp")
```

Otherwise, modulr will detect any change in the module's definition (even docstrings) and re-evaluate accordingly:

```{r}
"timestamp" %provides% {
  #' Return a string containing a timestamp with more information.
  format(Sys.time(), "%Y-%m-%d %H:%M:%OS6")
}

make("timestamp")
```

## Modules returning a function (prototypes)

```{r, echo=FALSE, results='hide', message=FALSE}
reset()
root_config$set(".")
```

This is a fact that all modules are singletons. Nonetheless, it is possible for a module to return a function (or closure) that itself returns a desired object. In this case, such a module fakes and behaves like a so-called _prototype_.

```{r}
"timestamp" %provides% {
  function() format(Sys.time(), "%H:%M:%OS6")
}
```

```{r}
make("timestamp")()

with_verbosity(0, make("timestamp")())
```

It is important to emphasize that the module is still a singleton: the second make call doesn't re-evaluate. But the function that is returned by the module is itself re-evaluated each time it is called.

## Modules returning a memoised function

```{r, echo=FALSE, results='hide', message=FALSE}
reset()
```

Singletons produce cached objects at make-time and prototypes produce computed objects at run-time. Memoised modules should produce cached objects at run-time. [Memoisation](https://en.wikipedia.org/wiki/Memoization) and [Hadley Wickam's memoise package](https://github.com/hadley/memoise) give an elegant solution to this requirement.

To see the essence of what is happening, we decrease the verbosity of modulr and define `foo` requiring `timestamp`, defined as a singleton at first:

```{r}
set_verbosity(1) # messages are shown only when changes occur

"timestamp" %provides% {
  # This is a singleton.
  message("'timestamp' is evaluated...")
  format(Sys.time(), "%H:%M:%OS6")
}

"foo" %requires% list(
  timestamp = "timestamp"
) %provides% {
  "foo"
}

make("foo")
```

In this example, `timestamp` is evaluated even though it is not explicitely used by `foo`. It just computes a timestamp, but it could be virtually very resource-consuming at make-time.

Let us re-define `timestamp` as a prototype:

```{r}
"timestamp" %provides% {
  # This is a prototype.
  function() {
    message("'timestamp' is evaluated...")
    format(Sys.time(), "%H:%M:%OS6")
  }
}

make("foo")
```

Here, the evaluation consists of defining a function that returns a timestamp, only when the function is explicitely called. Even if the computation encapsulated by the function is very resource-consuming, no evaluation of the returned function takes place at make-time.

Finally, let us re-define `timestamp` as a memoised module:

```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
library(memoise)
```

```{r}
"timestamp" %provides% {
  # This is a memoised module.
  memoise::memoise(
    function() {
      message("'timestamp' is evaluated...")
      format(Sys.time(), "%H:%M:%OS6")
    }
  )
}

make("foo")
```

The `timestamp` module returns a function which will be evaluated only when explicitely called at run-time. Let us re-define `foo` in order that it uses `timestamp`.

```{r}
"foo" %requires% list(
  timestamp = "timestamp"
) %provides% {
  message("It is ", timestamp())
  "foo"
}

make("foo")
```

Here, a timestamped message is outputed. Let us force the re-evaluation of `foo`.

```{r}
touch("foo")
make("foo")
```

The memoised version of `timestamp` is evaluated only at run-time, not at make-time; moreover, the string containing the actual timestamp is computed only once and then cached for future calls, avoiding re-evaluation.

To force re-evaluation of the memoised function exposed by `timestamp`, use `memoise::forget`.

```{r}
memoise::forget(make("timestamp"))
touch("foo")
make("foo")
```

## Modules returning a future

Using [Henrik Bengtsson's future package](https://cran.r-project.org/web/packages/future), it is possible to evaluate modules asynchronously using various resources available to the user. For instance, evaluation of modules can be eager, lazy, and/or parallelized (on multiple cores and/or a cluster).

```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
modulr::reset()
library(future)
```

```{r}
# How many cores are available?
availableCores()

"foo" %provides% {
  future({
    Sys.sleep(2L)
    "Hello"
  }) %plan% multicore
}

"bar" %provides% {
  future({
    Sys.sleep(2L)
    "World"
  }) %plan% multicore
}

"foobar" %requires% list(
  f = "foo",
  b = "bar"
) %provides% {
  paste0(value(f), " ", value(b), "!")
}

system.time(print(make("foobar")))
```

It is often interesting to parallelize an already existing module. `modulr` comes with the handy `futurize` function for this purpose.

```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
modulr::reset()
```

```{r}
"foo" %provides% { Sys.sleep(2L); "Hello" }
"bar" %provides% { Sys.sleep(2L); "World" }
"foobar" %requires% list(
  f = "foo", 
  b = "bar"
) %provides% {
  paste0(f, " ", b, "!")
}

futurize("foo", strategy = multicore)
futurize("bar", strategy = multicore)

futurize(
  "foobar", 
  name = "foobar/eager", 
  dependencies = list(f = "foo/future", b = "bar/future"),
  strategy = eager
)

system.time(fb_eager <- make("foobar/eager"))
system.time(print(value(fb_eager)))
```

```{r}
touch("foo/future")
touch("bar/future")
futurize(
  "foobar", 
  name = "foobar/lazy", 
  dependencies = list(f = "foo/future", b = "bar/future"),
  strategy = lazy
)

system.time(fb_lazy <- make("foobar/lazy"))
system.time(print(value(fb_lazy)))
```

## Modules returning an environment and option modules

```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
modulr::reset()
```

TODO

## Modules returning a list

It is also possible to define modules which simultaneously present the above properties:

```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
modulr::reset()
```

```{r}
"timestamp" %provides% {
  timestamp <- function() {
    message("'timestamp' is evaluated...")
    format(Sys.time(), "%H:%M:%OS6")
  }
  list(
    singleton = timestamp(),
    prototype = timestamp,
    memoised = memoise(timestamp),
    future = future(timestamp()) %plan% multicore
  )
}

timestamp %<=% "timestamp"

timestamp$singleton
timestamp$prototype()
timestamp$prototype()
timestamp$memoised()
timestamp$memoised()
value(timestamp$future)
```

## Modules with post evaluation hook: no-scoped and ephemeral

TODO

# Organizing modules

## In-memory
## On-disk

TODO:

- module defined along another module

## Semantic versioning

# Documenting, debugging and testing modules

## Docstrings
## Breadcrumbs

TODO :

- breakpoints dans RStudio

## Mocks

# Sharing modules

## Bundles
## _Gears_

# Advanced usage

## Special module `modulr`

TODO:

- hook
- toutes les autres méthodes exposées par le module "modulr"

## Scripting
## Encryption
## Package isolation
## Parallelization

# Scenarios
